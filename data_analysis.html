<!DOCTYPE html>
<html lang="en">
<head>
  <title>Intro to Programming Nanodegree Notes by bjemcnally</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="notes.css">
</head>
    
<body>
    
<div class="Navigation">
  <a href="http://www.udacity.com" target="_blank"><img src="udacity.png" alt="Udacity Icon" width="200" height="100"></a>
  <h1>Intro to Programming Nanodegree Notes</h1>
  <img src="waves.png" alt="waves" width="100" height="100" class="Center">
  <h3 class="NotesTitle">bjemcnally | Fall 2016</h3>
  <h3 class="NotesTitle">Use these buttons to navigate:</h3>
  <div class="Nav">
    <div class="Button">
      <a href="index.html">Welcome</a>
    </div>
    <div class="Button">
      <a href="notes.html#ZeroStage">Stage 0</a>
    </div>
    <div class="Button">
      <a href="notes.html#FirstStage">Stage 1</a>
    </div>
    <div class="Button">
      <a href="notes2.html">Stage 2</a>
    </div>
    <div class="Button">
      <a href="notes3.html">Stage 3</a>
    </div>
    <div class="Button">
      <a href="notes4and5.html#FourthStage">Stage 4</a>
    </div>
    <div class="Button">
      <a href="notes4and5.html#FifthStage">Stage 5</a>
    </div>
    <div class="Button">
      <a href="data_analysis.html">Data Analysis Elective</a>
    </div>
  </div>
    <h3 class="NotesTitle">Comments &amp; Suggestions Welcome!</h3>
</div>

<div class="NotesMaster"><!-- this one surrounds all of the notes -->

<div><!-- this surrounds all of the Elective notes -->
<h2 class="StageTitle" id="FourthStage">Data Analysis Elective</h2>
  <h3 class="NotesTitle">Lesson 0: Dictionaries (<a href="dictionaries.py">relevant. py</a>)</h3>
    <p><b>Using Dictionaries</b></p>
      <p>Dictionaries are another data type (like strings and lists)</p>
      <p>Create using curly brackets: { and } </p>
      <p>Entries in a dictionary are key:value pairs, e.x.: <span class="inline_code">{'hydrogen':1, 'helium':2}</span></p>
      <p><b>Keys</b> can be any immutable value: strings, numbers, etc.</p>
      <p><b>Values</b> can by any value</p>
      <p>Recall that strings are immutable and lists are mutable. Dictionaries are also mutable: we can add new key:value pairs and we can change the values of values (lol)</p>
      <p>Recall that we can index strings (string_name[character#]) and lists (list_name[value#]). For dictionaries the syntax is different: dictionary_name[key] and the value associated with that key is returned</p>
      <p>Like with lists, we can replace the value associated with a particular key (again, they are mutable), e.x. <span class="inline_code">dictionary_name[key] = new_value</span></p>
      <p>Elements in a dictionary are not ordered so when we print it out they may appear in a different order than originally written</p>
      <p><b>KeyError</b> indicates that a particular element is not in the dictionary</p>
      <p>Like lists, we can use <span class="inline_code">in</span> to determine if a particular element is in our dictionary</p>
      <p>To add an element...</p>
        <div class="Code">
            <p>elements = { 'hydrogen': 1, 'helium': 2, 'carbon': 6 }</p>
            <p>elements['lithium'] = 3</p>
        </div>
      <p>Generically speaking the syntax is: <span class="inline_code">dictionary_name['new_key'] = new_value</span></p>
      <p>The same syntax is used to modify an assigment!</p>
    <p><b>Population Quiz (<a href="population_quiz.py">relevant .py</a>)</b></p>
    <p><b>A Noble Gas (<a href="noble_gas.py">relevant .py</a>)</b></p>
    <p>A dictionary can be an element in a dictionary and individual values in the element dictionary can be indexed (as we did with elements within a list that is an element in a list)</p>
    <div class="InterestingNotes">
      <p>Notes from a recorded session regarding dictionaries in Python:</p>
      <ul>
        <li><span class="inline_code">print dictionary_name.keys()</span> returns a list of all of the keys used in a dictionary</li>
      </ul>
    </div>

  <h3 class="NotesTitle">Lesson 1: Data Analysis Process</h3>
    <p><b>Data Analysis Process</b></p>
    <ol>
      <li>Question you want to answer or problem you want to solve</li>
      <li>Data wrangling: data acquisition and data cleaning
        <p>Can happen via file download, accessing an API, scraping a webpage and/or combining from different formats</p>
      </li>
      <li>Data exploration: get familiar with data, build intuition, and find patterns</li>
      <li>Draw conclusions or make predictions, usually requires statistics or machine learning</li>
      <li>Communicate findings: blog post, paper, email, PowerPoint, conversatio. Data visualization is almost always useful here!</li>
    </ol>
    <p>This process is not necessarily linear! Sometimes data acquisition happens before you generate your question, etc.</p>
    <p><b>IPython Notebook</b></p>
    <p>allows you to combine code, plots, output, and descriptions into one easily readable document</p>
    <p>To open a notebook, use CLI to navigate to the correct directory and then run the command:</p>
      <p><span class="inline_code">jupyter notebook ipython_notebook_name.ipynb</span></p>
    <p>This will open the notebook in the default browser</p>
    <p><b>Pandas</b> is a software library used for data analysis, more on this lateR</p>
    <p><b>CSVs</b></p> (L1_Starter_Code.ipynb)
    <p>Comma separated values, like a spreadsheet without formulas, easy to manipulate using code</p>
    <p>You can represent a CSV yas a list of rows:</p>
      <ul>
        <li>Each row can be a list</li>
        <li>Each row can be a dictionary where keys are heading names</li>
      </ul>
    <p>From <a href="https://docs.python.org/2/library/csv.html">CSV</a> module documentation: the <span class="inline_code">csv</span> (or <span class="inline_code">unicodecsv</span>) module implements classes to read and write tabular data in CSV format uing <span class="inline_code">reader</span> and <span class="inline_code">writer</span> objects. Programmers can also read and write data in dictionary form using <span class="inline_code">DictReader</span> and <span class="inline_code">DictWriter</span> classes.</p>
    <p>Using an <b>iterator</b> lets you write a <span class="inline_code">for</span> loop to access each element, but you can only loop over an iterator once. Iterators are useful when you don't know what is in your list (or whatever you want to iterate over).</p>
    <p>More about iterators (<a href="https://www.codementor.io/python/tutorial/python-generators-and-iterators">source</a>):</p>
    <ul>
      <li>For loops loop over iterables (like lists)</li>
      <li>iterables have <span class="inline_code">__iter__</span> functions</li>
      <li><span class="inline_code">__iter__</span> functions return Iterators</li>
      <li>Iterators make use of the <span class="inline_code">next</span> method to move from element to element within the assoicated iterable</li>
      <li>Once an iterator runs out of things to return from the <span class="inline_code">next</span> function it raises the <span class="inline_code">StopIteration</span> exception whenever next is called</li>
    </ul>
    <p>Remember, anytime you find yourself copying and pasting code or writing two pieces of code that are very similar, it might be best to write a function instead!</p>
    <p><b>Fixing Data Types</b></p>
    <p><span class="inline_code">csv</span> library sees everything as strings, it's up to you to convert them to integers, dates, etc. (if you want)</p>
    <p>It might be best to update datatypes up front to make things easier</p>
    <p>When converting numbers stored as strings, it may be necessary to convert to floating point before converting to integer (depending on the nature of the data)</p>
    <p><b>Questions about student data</b></p>
    <p>e.x. How long do students take to submit projects?</p>
    <p>What are 5 questions you can ask of these data? My answers:</p>
    <ul>
      <li>What proportion of students complete a course?</li>
      <li>On average, how long does it take for students to complete a course?</li>
      <li>On average, once a project is submitted, how long does it take to be evaluated? (in days)</li>
      <li>For students who cancel their enrollment, what is the average length of their enrollment?</li>
      <li>What proportion of student project submission receive 'DISTINCTION' rating?</li>
    </ul>
    <p>Other questions:</p>
    <ul>
      <li>How much time students spend taking classes</li>
      <li>How time spent relates to lessons/projects completed</li>
      <li>How engagment changes</li>
      <li>How many times students submit project</li>
    </ul>
    <p>We will focus on: <b>How do students who pass their projects differ from those who don't?</b></p>
    <p><b>Investigating the data</b></p>
    <p>For each of the files, find the total number of rows in the csv and the number of unique students...</p>
    <p>Video answer used <span class="inline_code">set()</span>... a module that provides classes for constructing and manipulating unordered collections of unique elements (more info <a href="https://docs.python.org/2/library/sets.html">here</a>)</p>
    <p><b>Lesson 1: Notes so far</b></p>
    <p>Got a little frustrated with the complete lack of explanations in Lesson 1 and how often I was getting stuck or just randomly guessing at answers. Took a day off and now I'm ready with a new game plan: go back through Lesson 1 to date and take notes on every part I didn't understand... Here we go!</p>
    <p>On the left will be the code from L1_Starter_Code.ipynb and on the right will be my notes about it...</p>
    <div class="CodeParent">
      <div class="CodeLeft">
        <p>import unicodecsv</p>
        <p>enrollments = []
        <br>f = open('enrollments.csv', 'rb')
        <br>reader = unicodecsv.DictReader(f)
        <br>for row in reader:
        <br>&nbsp;&nbsp;enrollments.append(row)
        <br>f.close()</p>
        <p># this is functionally equivalent to:</p>
        <p>with open('enrollments.csv', 'rb') as f:
        <br>&nbsp;&nbsp;reader = unicodecsv.DictReader(f)
        <br>&nbsp;&nbsp;enrollments = list(reader)</p>
      </div>
      <div class="CodeRight">
        <ul>
          <li><b>Unicode</b> from Google: "an international encoding standard for use with different languages and scripts, by which each letter, digit, or symbol is assigned a unique numeric value that applies across different platforms and programs"</li>
          <li><b>CSV</b> from doc: "is the most common import and export format for spreadsheets and databases"</li>
          <li><span class="inline_code">csv</span> module allows you to read, write, etc to CSVs</li>
          <li><b>'r'</b> indicates the file should be read, the b in <b>'rb'</b> indicates binary format (binary data includes images, sound files,etc). <em>Not sure why this is necessary here...?</em></li>
          <li><span class="inline_code">.DictReader(file_name.csv,fieldnames)</span> is a <span class="inline_code">class</span> within <span class="inline_code">csv</span>module that creates an object that maps the information read into a dictionary whose keys are given by the optional fieldnames parameter. If fieldnames is omitted, the values in the first row (i.e. header) of the CSV will be used as the fieldnames/keys</li>
          <li><em>The code at right in generating a list (enrollments) where each list element is a row from the CSV that becomes a dictionary where the dictionary keys are taken from the header row</em></li>
          <li><span class="inline_code">with</span> keyword is useful when dealing with files because it ensures the file is closed after it is used (you don't need to explicitly close it)</li>
          </ul>
      </div>
    </div>
      <p>Question 1 repeats this for the other two CSV files</p>
      <p>Fixing Data Types</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>from datetime import datetime as dt</p>
          <p>def parse_date(date):
          <br>&nbsp;&nbsp;if date == '':
          <br>&nbsp;&nbsp;&nbsp;&nbsp;return None
          <br>&nbsp;&nbsp;else:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;return dt.strptime(date, '%Y-%m-%d')</p>
          <p>def parse_maybe_int(i):
          <br>&nbsp;&nbsp;if i == '':
          <br>&nbsp;&nbsp;&nbsp;&nbsp;return None
          <br>&nbsp;&nbsp;else:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;return int(i)</p>
          <p># Clean up the data types in 'enrollments'</p>
          <p>for enrollment in enrollments:
          <br>&nbsp;&nbsp;enrollment['cancel_date'] = parse_date(enrollment['cancel_date'])
          <br>&nbsp;&nbsp;enrollment['days_to_cancel'] = parse_maybe_int(enrollment['days_to_cancel'])
          <br>&nbsp;&nbsp;enrollment['is_canceled'] = enrollment['is_canceled'] == 'True'
          <br>&nbsp;&nbsp;enrollment['is_udacity'] = enrollment['is_udacity'] == 'True'
          <br>&nbsp;&nbsp;enrollment['join_date'] = parse_date(enrollment['join_date'])</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li><b>Parsing</b> is the process of analysing a string of symbols</li>
            <li><span class="inline_code">datetime</span> module supplies classes for manipulating dates and times in simple and complex ways with the focus on efficient attribute extraction for output formatting and manipulation</li>
            <li><span class="inline_code">as</span> keyword lets you create a shorthand (e.x. type dt instead of datetime each time you use the module)</li>
            <li><span class="inline_code">.strptime(date_string, format)</span> reformats the date from a string to the desired format (e.x. '%Y-%m-%d')</li>
            <li><span class="inline_code">int()</span> turns strings into integers</li>
          </ul>
        </div>
      </div>
      <p>Problems in the Data / Question 3</p>
      <p>This is before question 2 here because it changes the answer to 2 slightly</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>for engagement_record in daily_engagement:
          <br>&nbsp;&nbsp;engagement_record['account_key'] = engagement_record['acct']
          <br>&nbsp;&nbsp;del[engagement_record['acct']]</p>
        </div>
        <div class="CodeRight">
          <p>Changes header 'acct' in daily_engagement table to 'account_key' to match the two other tables</p>
          <p>Essentially reassigns the key's name and the deletes the old key name</p>
        </div>
      </div>
      <p>Investigating the Data / Question 2</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>unique_enrolled_students = set()
          <br>for enrollment in enrollments:
          <br>&nbsp;&nbsp;unique_enrolled_students.add(enrollment['account_key'])
          <br>len(unique_enrolled_students)</p>
          <p># bc we already complete Question 3
          <br># we can create a function to do this:</p>
          <p>def find_unique_accounts(table_name):
          <br>&nbsp;&nbsp;set_of_accounts = set()
          <br>&nbsp;&nbsp;for each in table_name:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;set_of_accounts.add(each['account_key'])
          <br>&nbsp;&nbsp;return set_of_accounts</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>The goal is to find the number of rows and the number of account keys in each table</li>
            <li>A set is another data structure in Python (like lists) that is an unordered collection with no duplicate elements. Basic uses include membership testing (is X in my list?) and eliminating duplicate entries. <span class="inline code">set()</span> function can be used to create sets or an empty set (as done at left)</li>
            <li>At left we create and empty set and then use a <span class="inline_code">for</span> loop to loop through each line of enrollments table (list of dictionaries) and add the account key to the set</li>
            <li>For lists you use <span class="inline_code">.append()</span> while for sets you use <span class="inline_code">.add()</span></li>
        </div>
      </div>
      <p>Missing Engagement Records / Question 4</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>for enrollment in enrollments:
          <br>&nbsp;&nbsp;student = enrollment['account_key']
          <br>&nbsp;&nbsp;if student not in engagement_unique_students:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;print enrollment
          <br>&nbsp;&nbsp;&nbsp;&nbsp;break</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Find and print student enrollment where the student is missing from daily engagement table.</li>
            <li>For each individual record in enrollments table, find 'account_key' in enrollments. If that account key is not in engagement_unique_students, print record.</li>
            <li>'Missing students' all canceled the same day they joined and days_to_cancel is 0</li>
          </ul>
        </div>
      </div>
      <p>Checking for More Problem Records / Question 5</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>count_surprising_records = 0
          <br>for enrollment in enrollments:
          <br>&nbsp;&nbsp;student = enrollment['account_key']
          <br>&nbsp;&nbsp;if student not in engagement_unique_students \
          <br>&nbsp;&nbsp;and enrollment['join_date'] != enrollment['cancel_date']:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;count_surprising_records += 1
          <br>&nbsp;&nbsp;&nbsp;&nbsp;print enrollment
          <br>print count_surprising_records</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Find number of enrollments missing from engagement table where they stayed enrolled at least one day (join and cancel are not the same day)</li>
            <li>These are all test accounts: 'is_udacity': True</li>
          </ul>
        </div>
      </div>
      <p>Tracking Down the Remaining Problems</p>
      <p>IIRC This portion of the code was provided and it's all pretty straightforward</p>
      <p>Refining the Question / Question 6</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>paid_students = {}
          <br>for each in non_udacity_enrollments:
          <br>&nbsp;&nbsp;if not each['is_canceled'] or \
          <br>&nbsp;&nbsp;each['days_to_cancel'] > 7:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;new_paid_key = each['account_key']
          <br>&nbsp;&nbsp;&nbsp;&nbsp;new_paid_value = each['join_date']
          <p>&nbsp;&nbsp;&nbsp;&nbsp;if new_paid_key not in paid_students or \
          <br>new_paid_value > paid_students[new_paid_key]:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paid_students[new_paid_key] = new_paid_value</p>
          <p>print len(paid_students)</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Create a dictionary (paid_students) containing all students who either haven't canceled yet or who remained enrolled for >7 days. keys should be account keys and values should be enrollment date</li>
            <li>Take into account students who cancel and then re-enroll, only keep their most recent start date</li>
            <li><span class="inline_code">if not</span> returns <span class="inline_code">False</span> if value is zero for numbers, length is 0 (for lists, dictionaries, etc), or value is <span class="inline_code">None</span>. Otherwise it returns <span class="inline_code">True</span></li>
            <li>Put another way: "<span class="inline_code">if not</span> checks for truth" and asks a value "are you meaningful or not?"</li>
            <li>value of is_canceled is either <span class="inline_code">True</span> or <span class="inline_code">False</span></li>
            <li>As a <span class="inline_code">boolean</span> operator (like and or or), <span class="inline_code">not</span> just takes the opposite: not True is the same a False, etc.</li>
            <li>If <em>either</em> returns <span class="inline_code">True</span>, continue to assign keys and values</li>
        </div>
      </div>
      <p>Getting Data from First Week / Question 7</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>def within_one_week(join_date, engagement_date):
          <br>&nbsp;&nbsp;time_delta = engagement_date - join_date
          <br>&nbsp;&nbsp;return time_delta.days < 7 and time_delta.days >= 0</p>

          <p>paid_engagement_in_first_week = []
          <br>for daily_record in daily_engagement:
          <br>&nbsp;&nbsp;if daily_record['account_key'] in paid_students:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;keep_engagement = daily_record['account_key']
          <br>&nbsp;&nbsp;&nbsp;&nbsp;join_date = paid_students[keep_engagement]<br>&nbsp;&nbsp;&nbsp;&nbsp;engage = daily_record['utc_date']
          <br>&nbsp;&nbsp;&nbsp;&nbsp;if within_one_week(join_date, engage) == True:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paid_engagement_in_first_week.append(daily_record)</p>
          <p>len(paid_engagement_in_first_week)</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Function returns <span class="inline_code">True</span> if a particular engagment record date is within 7 days of their join date</li>
            <li>Create a list of rows from the engagement table including only rows where the student is one of the paid students, and the date is within one week of the student's join date.</li>
            <li>This is my answer, which was different from the video answer, however, I obtained the same result so I'll leave it as is for now</li>
          </ul>
        </div>
      </div>
      <p>Exploring Student Engagement</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>from collections import defaultdict</p>
          <p>engagement_by_account = defaultdict(list)
          <br>for engagement_record in paid_engagement_in_first_week:
          <br>&nbsp;&nbsp;account_key = engagement_record['account_key']
          <br>&nbsp;&nbsp;engagement_by_account[account_key].append(engagement_record)</p>

          <p>total_minutes_by_account = {}
          <br>for account_key, engagement_for_student in engagement_by_account.items():
          <br>&nbsp;&nbsp;total_minutes = 0
          <br>&nbsp;&nbsp;for engagement_record in engagement_for_student:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;total_minutes += engagement_record['total_minutes_visited']
          <br>&nbsp;&nbsp;total_minutes_by_account[account_key] = total_minutes</p>

          <p>import numpy as np</p>
          <p>total_minutes = total_minutes_by_account.values()
          <br>print 'Mean:', np.mean(total_minutes)
          <br>print 'Standard deviation:', np.std(total_minutes)
          <br>print 'Minimum:', np.min(total_minutes)
          <br>print 'Maximum:', np.max(total_minutes)</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>This code was all provided, just taking notes here</li>
            <li>First part: Create a dictionary of engagement grouped by student. The keys are account keys, and the values are lists of engagement records.</li>
            <li><span class="inline_code">collections</span> is a module that contains "high-performance container datatypes"</li>
            <li><span class="inline_code">defaultdict</span> is a "dict subclass that calls a factory function to supply missing values", used to "group a sequence of key-value pairs into a dictionary of lists". If they key already exists in the list, add the new value to the existing list element with that key...</li>
            <li>Second part: Create a dictionary with the total minutes each student spent in the classroom during the first week. The keys are account keys, and the values are numbers (total minutes)</li>
            <li><span class="inline_code">dictionary_name.items()</span> returns a list of the dictionary's key, value pairs that we loop through in the next line (this is required in order the loop a dictionary)</li>
            <li>Syntax for looping through a dictionary:
              <div class="Code">
                <p>for key, value in dict.items():
                <br>&nbsp;&nbsp;print(k,v)</p>
              </div></li>
            <li>Last part: Summarize the data about minutes spent in the classroom</li>
            <li><span class="inline_code">dictionary_name.values()</span> returns a list of all of the values in the dictionary</li>
            <li><span class="inline_code">np.mean(list_name)</span> etc. performs desired calculation</li>
          </ul>
        </div>
      </div>
      <p>Debugging Data Analysis Code / Question 8</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>student_with_max_minutes = None
          <br>max_minutes = 0</p>

          <p>for student, total_minutes in total_minutes_by_account.items():
          <br>&nbsp;&nbsp;if total_minutes > max_minutes:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;max_minutes = total_minutes
          <br>&nbsp;&nbsp;&nbsp;&nbsp;student_with_max_minutes = student</p>

          <p>print max_minutes</p>

          <p>for engagement_record in paid_engagement_in_first_week:
          <br>&nbsp;&nbsp;if engagement_record['account_key'] == student_with_max_minutes:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;print engagement_record
        </div>
        <div class="CodeRight">
          <ul>
            <li>Go through a similar process as before to see if there is a problem. Locate at least one surprising piece of data, output it, and take a look at it.</li>
            <li>Copied from above: <span class="inline_code">dictionary_name.items()</span> returns a list of the dictionary's key, value pairs that we loop through in the next line (this is required in order the loop a dictionary)</li>
            <li>I did not get the answer to this, so this is the solution code.</li>
            <li>Here we loop through the total_minutes_by_account dictionary to find and print the highest value (max_minutes) and find the account key for this student (student_with_max_minutes</li>
            <li>Then, we loop through paid_engagement_in_first_week list and print the engagement records for this student</li>
            <li>The problem was the the max minutes was higher than the number of minutes in a week so there must have been something wrong with the code. When that students' records were printed we noticed that there were more than 7 of them in paid_engagement_in_first_week.</li>
            <li>To fix this she added "and time_delta.days >= 0" after time_delta.days < 7 in within_one_week function</li>
            <li>Correct Maximum = 3564.73 or ~60 hours</li>
          </ul>
        </div>
      </div>
      <p>Lessons Completed in First Week / Question 9</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>from collections import defaultdict
          <br>import numpy as np</p>
          
          <p>def group_data(data, key_name):
            <br>&nbsp;&nbsp;grouped_data = defaultdict(list)
            <br>&nbsp;&nbsp;for data_point in data:
              <br>&nbsp;&nbsp;&nbsp;&nbsp;key = data_point[key_name]
              <br>&nbsp;&nbsp;&nbsp;&nbsp;grouped_data[key].append(data_point)
            <br>&nbsp;&nbsp;return grouped_data</p>
            
            <p>engagement_by_account = group_data(paid_engagement_in_first_week, 'account_key')</p>

          <p>def sum_grouped_items(grouped_data, field_name):
            <br>&nbsp;&nbsp;summed_data = {}
            <br>&nbsp;&nbsp;for key, data_points in grouped_data.items():
            <br>&nbsp;&nbsp;&nbsp;&nbsp;total = 0
            <br>&nbsp;&nbsp;&nbsp;&nbsp;for data_point in data_points:
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total += data_point[field_name]
            <br>&nbsp;&nbsp;&nbsp;&nbsp;summed_data[key] = total
            <br>&nbsp;&nbsp;return summed_data</p>

          <p>total_lessons2 = sum_grouped_items(engagement_by_account, 'lessons_completed')</p>

          <p>def print_statistics(data):
            <br>&nbsp;&nbsp;print 'Mean:', np.mean(data)
            <br>&nbsp;&nbsp;print 'Standard deviation:', np.std(data)
            <br>&nbsp;&nbsp;print 'Minimum:', np.min(data)
            <br>&nbsp;&nbsp;print 'Maximum:', np.max(data)</p>

          <p>print_statistics(total_lessons2.values())</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Adapt the code above to find the various stats for the number of lessons completed by each student during the first week. Try creating one or more functions to re-use the code above.</li>
            <li>group_data function takes in some data and groups it by some key name (here we generally use it to group each students' records together)</li>
            <li><em>library Pandas has a built-in function that works in a similar way</em></li>
            <li>sum_grouped_items takes in a dictionary (grouped_data) and creates a new dictionary where each students' grouped data is totaled (e.x. number of minutes spend on course in first week, etc.)</li>
            <li>print_statistics function calculates and prints a few interesting stats</li>
            <li><span class="inline_code">values.()</span> uses just the values from the dictionary and ignores the keys</li>
          </ul>
        </div>
      </div>

      <p>Number of Visits in First Week</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>def num_records(grouped_data, field_name):
            <br>&nbsp;&nbsp;summed_data = {}
            <br>&nbsp;&nbsp;for key, data_points in grouped_data.items():
            <br>&nbsp;&nbsp;&nbsp;&nbsp;total = 0
            <br>&nbsp;&nbsp;&nbsp;&nbsp;for data_point in data_points: 
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data_point[field_name] > 0:
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total += 1
            <br>&nbsp;&nbsp;&nbsp;&nbsp;summed_data[key] = total
            <br>&nbsp;&nbsp;return summed_data</p>

            <p>num_days_first_week = num_records(engagement_by_account, 'total_minutes_visited')
            <br>print_statistics(num_days_first_week.values())</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Find the mean, standard deviation, minimum, and maximum for the number of days each student visits the classroom during the first week.</li>
            <li>num_records counts the number of records where a field_name (e.x. time spent studying) is greater than 0</li>
          </ul>
        </div>
      </div>

      <p>Splitting Out Passing Students / Question 11</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>subway_project_lesson_keys = ['746169184', '3176718735']</p>
          
          <p>pass_subway_project = set()
          <br>for each in paid_submissions:
          <br>&nbsp;&nbsp;if each['lesson_key'] in subway_project_lesson_keys:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;if each['assigned_rating'] == 'PASSED' \
          <br>&nbsp;&nbsp;&nbsp;&nbsp;or each['assigned_rating'] == 'DISTINCTION':
          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_subway_project.add(each['account_key'])</p>
          
          <p>rint str(len(pass_subway_project)) + " students passed subway project (this is correct)"</p>
          
          <p>passing_engagement = []
          <br>non_passing_engagement = []</p>
          
          <p>for engagement_record in paid_engagement_in_first_week:
          <br>&nbsp;&nbsp;if engagement_record['account_key'] in pass_subway_project:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;passing_engagement.append(engagement_record)
          <br>&nbsp;&nbsp;else:
          <br>&nbsp;&nbsp;&nbsp;&nbsp;non_passing_engagement.append(engagement_record)</p>
          
          <p>print len(passing_engagement)
          <br>print len(non_passing_engagement)</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Create two lists of engagement data for paid students in the first week. The first list should contain data for students who eventually pass the subway project, and the second list should contain data for students who do not. Find len of each.</li>
            <li>Create a <span class="inline_code">set()</span> of account_keys for students who passed the subway project</li>
            <li>Create a list of engagement records for those who did/n't pass and find its length</li>
          </ul>
        </div>
      </div>

      <p>Comparing Two Student Groups / Question 12</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>passing_grouped = group_data(passing_engagement, 'account_key')
          <br>non_passing_grouped = group_data(non_passing_engagement, 'account_key')</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Compute some metrics you're interested in and see how they differ for students who pass the subway project vs. students who don't, e.x.: minutes spent in the classroom, lessons completed, days visited</li>
            <li>After grouping the data by student for non/passing students by account key, the individual data points were summed and stats calculated for the metrics indicated above</li>
          </ul>
        </div>
      </div>

      <p>Making Histograms / Question 13</p>
      <p>To make a histogram Python, you can use the matplotlib library which comes with Anaconda. e.x.:</p>
        <div class="Code">
          <p>data = [1, 2, 1, 3, 3, 1, 4, 2]</p>
          
          <p>%matplotlib inline
          <br>import matplotlib.pyplot as plt
          <br>plt.hist(data)</p>
        </div>
      <p>The line <span class="inline_code">%matplotlib inline</span> is specifically for IPYNB, if you are not using a notebook exlude this line and add <span class="inline_code">plt.show()</span> at the bottom to show the plot in a new window (e.x. <a href="histogram.py">histogram.py</a>)</p> 
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>%matplotlib inline
          <br>import matplotlib.pyplot as plt</p>

          <p>def make_histogram(list_name):
            <br>plt.hist(list_name)</p>
          
          <p>passing_minutes_list = passing_minutes.values()
          <br>non_passing_minutes_list = non_passing_minutes.values()</p>
          
          <p>print "Minutes spent in classroom for students who passed first project:"
          <br>make_histogram(passing_minutes_list)</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Make histograms of the three metrics we looked at earlier for both students who passed the subway project and students who didn't. You might also want to make histograms of any other metrics you examined.</li>
            <li>I created a function to make histograms and then saved created a list for each set of data created in Question 12 (dictionary) using <span class="inline_code">.values()</span></li>
            <li>The weird gaps in the Days Visited histograms are due to the number of bins used, we will fix this later</li>
            <li>Probably a good idea to add <span class="inline_code">plt.hist(list_name)</span> to our <span class="inline_code">print_statistics</span>
            function so the histograms show up next to the statistics</li>
          </ul>
        </div>
      </div>

      <p>Improving Plots and Sharing Findings / Question 14</p>
      <p>Tentative conclusion: students who pass the subway project spend more minutes in the classroom during their first week</p>
      <p>Need to use <em>statistics</em> to determine if these differences are real or due to random chance</p>
      <p>Correlation does not imply causation</p>
      <p><em>A/B Testing!</em></p>
      <p>Making predictions based on data analysis results...<em>machine learning</em> can make predictions automatically, usually a lot better than those you can make by hand</p>
      <p>Communicate findings: What findings are most interesting? How will you present them?</p>
      
      <p><b>Adding labels and titles</b></p>
      <p>In matplotlib you can add axis labels and a title (note that histograms usually only need x-axis labels):</p>
        <div class="Code">
          <p>plt.xlabel("Label for x axis")
          <br>plt.ylabel("Label for y axis")
          <br>plt.title("Title of plot")</p>
        </div>
      
      <p><b>Making plots look nicer with seaborn</b></p>
      <p>To install seaborn, open terminal/CLI and type: <span class="inline_code">conda install seaborn</span></p>
      <p>To use it import it using: <span class="inline_code">import seaborn as sns</span></p>
      <p><b>Adding extra arguments to your plot</b></p>
      <p>See documentation for hist function for more info. One example is to pass the <span class="inline_code">bins</span> argument which sets the number of bins used by your histogram, e.x.: <span class="inline_code">plt.hist(list_name, bins=20)</span></p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>import seaborn as sns</p>
          <p>print 'white: Passing Students'
          <br>plt.hist(passing_days_visited_list, bins=8, alpha=0.8, color="white", orientation="vertical", label="Passing Students")
          <br>plt.xlabel("Number of Days")</p>
          
          <p>print 'green: Non-passing Students'
          <br>plt.hist(non_passing_days_visited_list, bins=8, alpha=0.6, color="green", orientation="vertical", label="Non-Passing Students")
          <br>plt.title("Distribution of Days Visited in First Week")</p>
          
          <p>plt.legend(loc='upper right')</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li>Importing seaborn automatically makes it look nicer, but you can also play with other parameters as I did</li>
            </ul>
        </div>
      </div>

      <p><b>Data analysis and related terms (Data Science, Data Engineering, Big Data)</b></p>
      <p>Data Science: similar to data analysis, more focused on building systems, may require more experience</p>
      <p>Data Engineering: more focused on data wrangling, involves data storage and processing</p>
      <p>Big Data: fuzzy term for "a lot" of data, data analysts, scientists, and engineers all work with "big data"</p>

      <p><b>Conclusions</b></p>
      <p>Additional libraries can make writing data analysis code much easier!</p>

  <h3 class="NotesTitle">Lesson 2: Numpy and Pandas for 1D Data</h3>

    <p><b>Introduction</b></p>
      <p>Numpy (numerical Python) and Pandas are two Python libraries, they take awhile to learn how to use, but they will make writing data analysis code a lot easier and code will run faster. We will use it for 1D data, e.x. a single column of a spreadsheet</p>

    <p><b>Gapminder Data</b></p>
      <p>Example questions:</p>
        <ul>
          <li>How has US employment varied over time? (or any other country)</li>
          <li>What are the highest/lowest employment levels? Which countries have them? Where does the US fall on the spectrum?</li>
          <li>How do these variables relate to each other?</li>
          <li>Are there consistent trends across countries?</li>
        </ul>

    <p><b>1D Data in Numpy and Pandas</b></p>
      <p>Recall from Lesson 1, the code we used to import data from CSV, generate a list using those data, and the generate a set() of unique student account keys and how long it takes to run... not only does Pandas require less code, it will run more quickly</p>
      <p>First <span class="inline_code">import pandas as pd</span></p>
      <p><span class="inline_code">new_file = pd.read_csv('filename.csv')</span> will read the csv</p>
      <p>Pandas builtin <span class="inline_code">.unique()</span> function will generate a set of unique values from a particular column, e.x. <span class="inline_code">new_file['column_name'].unique()</span></p>

    <p><b>Quiz: Numpy Arrays</b></p>
      <p>1D data in Pandas = <b>series</b> and in Numpy = <b>array</b>, Pandas series have more features than Numpy arrays, but arrays are simpler so we will start with them. Array is similar to a Python List: you can access elements by position (<span class="inline_code">array_name[0]</span>), access a range of elements (<span class="inline_code">array_name[1:3]</span>, just like for lists, the upper bound is not inclusive!), and use <span class="inline_code">for</span> loops</p>
      <p>Differences between Numpy arrays and Python lists: each element should have the same type (e.x. string, int, boolean, etc), contains convenient functions (mean(), std()), can be multidimensional (e.x. like making a list of lists in Python)</p>
      <p>Recall that <span class="inline_code">array_name[:]</span> references the entire array (or Python list)</p>
      <p><span class="inline_code">array_name.dtype</span> will tell you what kind of data the array contains (e.x. string, int, float,), for strings it will also tell you the length of the longest one in the array (S22 = longest string is 22 characters)</p>
      <div class="Code">
        <p>for item in array:
          <br>&nbsp;&nbsp;print 'Some text, {}'.format(item)</p>
      </div>
      <p>The above code will loop through the array and print 'Some text,' followed by the item</p>
      <p>Python's <span class="inline_code">.format()</span> function will find each occurrence of <span class="inline_code">{}</span> (curly brackets) and replace them as indicate in the parentheses (see above example)</p>
      <p>After importing Numpy, you can do basic calculations on arrays:
        <br><span class="inline_code">array_name.mean()</span> or <span class="inline_code">.std()</span> or <span class="inline_code">.max()</span> etc.</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>def max_employment(countries, employment):
          <br>&nbsp;&nbsp;max_country = None
          <br>&nbsp;&nbsp;max_employment = 0</p>
          <p>&nbsp;&nbsp;for each in range(len(countries)):
          <br>&nbsp;&nbsp;&nbsp;&nbsp;country = countries[each]
          <br>&nbsp;&nbsp;&nbsp;&nbsp;country_employment = employment[each]</p>
          <p>&nbsp;&nbsp;&nbsp;&nbsp;if country_employment > max_employment:
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_country = country
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_employment = country_employment</p>
          <p>&nbsp;&nbsp;return (max_country, max_employment)</p>
        </div>
        <div class="CodeRight">
          <p>Loop through each and replace max values until max is found</p>
          <p>Good to know: <b>If you can find a Numpy function to do what you want, you can always treat the arrays as a Python list and write code that way!</b></p>
        </div>
      </div>
      <p>To solve this in Numpy:</p>
      <div class="CodeParent">
        <div class="CodeLeft">
          <p>def max_employment2(countries, employment):
            <br>&nbsp;&nbsp;index = employment.argmax()
            <br>&nbsp;&nbsp;return (countries[index], employment[index])</p>
        </div>
        <div class="CodeRight">
          <ul>
            <li><span class="inline_code">.argmax()</span> finds the max and returns its position in the array! (this is what I was looking for)</li>
          </ul>
        </div>
      </div>
      <p>To create a Numpy array:</p>
      <div class="Code">
        <p>import numpy as np
          <br>array_name = np.array(['first element', 'second element'
          <br>&nbsp;&nbsp;])</p>
      </div>
      <p>What you are doing is first creating a Python list and then calling <span class="inline_code">np.array()</span> to convert it to an array</p>

    <p><b>Quiz: Vectorized Operations</b></p>
      <p>A vector is list of numbers and in linear algebra (and Numpy!) you can add two vectors of the same length, this is called <b>vector addition</b>. This sums the values in each index together vector1[0] + vector2[0] = vector3[0] (if vector1[0] = 2 and vector2[0] = 4 then vector3[0] = 6)</p>
      <p>Note that the outcome is NOT list concatenation as in Python! These are arrays so they are treated differently!</p>

    <p><b>Quiz: Multiplying by a Scalar</b></p>
      <p>Scalar = a single number (e.x. 3)</p>
      <p>vector = [1, 2, 3] and you multiply by three...
        <br>for a Python list you'd get [1, 2, 3, 1, 2, 3, 1, 2, 3]
        <br>but in linear algebra/Numpy you'd get [3, 6, 9]</p>

    <p><b>Quiz: Calculate Overall Completion Rate</b></p>
      <p>More vectorized operations: +, -, *, /, **</p>
      <p>If you have a vector of booleans you can perform logical operations using symbols: ampersand (and), | (or), ~ (not)</p>
      <p>You can also use standard comparison operations: >, >=, ==, !=, etc.</p>
      <p>Using vectorized operations makes for cleaner code and is often faster than using a loop when working with 2+ vectors</p>
      <p>My answer to this quiz is in my Lesson 2 jupyter notebook</p>

    <p><b>Quiz: Standardizing Data</b></p>
      <p>How does one data point compare to the rest? e.x. employment in US versus other countries</p>
      <p>To do this, convert each data point to the number of standard deviations away from the mean (+/-)</p>
      <p>Find mean and stdev then create a new array where each data point has been replaced as indicated above (see jupyter notebook)</p>

    <p><b>Quiz: Numpy Index Arrays</b></p>
      <p>Suppose you have two Numpy arrays of the same length, and the second contains booleans (an <em>index array</em>, it tells you which elements of the first array to keep), e.x.:</p>
      <div class="Code">
        <p>a = [1, 2, 3, 4, 5]
        <br>b = [F, F, T, T, T]
        <br>a[b] --> [3, 4, 5]</p>
      </div>
      <p>In the above case, we kept every number > 2. There are two potential ways to make an index array to help do this: <span class="inline_code">b = a > 2</span> or <span class="inline_code">a[a>2]</span>. The second is a clear way of saying "keep all the elements of a that are > 2": a is an array and "a > 2" is a vectorized operation that returns an array of booleans (i.e. generates an index array to compliment a). This is faster than writing a loop, although both will accomplish the same goal.</p>
      <p>For quiz, see relevant portion of Lesson_2.ipynb</p>
    
    <p><b>Quiz: + vs. +=</b></p>
      <p>+= modifies the existing array</p>
      <p>+ adds to the array creating a <b>new</b> array!</p>

    <p><b>Quiz: In-Place vs Not In-Place</b></p>
      <p>+= operates in-place while + does not</p>
      <p>i.e. += is storing the new values in the same place the original values were stored, rather than creating a new array to store them in</p>
      <p>Unlike Python lists, with arrays, <b>slice</b> refers to a <b>view</b> of the original array. It will look like a new array, but if you modify it, the original array changes:</p>
      <div class="Code">
        <p>import numpy as np
          <br>a = np.array([1, 2, 3, 4, 5])
          <br>slice = a[:3] # slice = [1, 2, 3]
          <br>slice[0] = 100 # slice = [100, 2, 3]
          <br>print a # a = [100, 2, 3, 4, 5]</p>
      </div>

    <p><b>Quiz: Pandas Series</b></p>
      <p>A series is similar to a Numpy array, but with extra functionality, e.x.: if you have a series "s" then <span class="inline_code">s.describe()</span> will print out mean, standard deviation, median, and some other statistics about your series (COOL!)</p>
      <p>Similarities between series and arrays: everything we just learned about arrays will also work on series (accessing elements, looping, convenient functions like mean() and max(), vectorized operations</p>
      <p>A hint for this quiz: <b>You can add booleans in Python! True = 1 and False = 0 so True + True = 2, etc.</b></p>
      <p>See Lesson_2.ipynb for my answer. Turns out these two variables are positively correlated!</p>
      <p>One last note, making a Pandas Series is very similar to creating a Numpy array. Start with a Python list:</p>
      <div class="Code">
        <p>import pandas as pd</p>
        <p>series_name = pd.Series([1, 2, 3, 4])</p>
      </div>

    <p><b>Quiz: Series Indexes</b></p>
      <p>The main difference between Series and Arrays is that Pandas Series have an <b>Index</b>. Series are like a cross between a list and a dictionary. For arrays we have been using one to store country names and a second to store numerical data (e.x. life expectancy), but this isn't not necessary for Series because they can store both, kind of like making a list with two lists: the first is the data (values, data) and the second is the country name (keys, indexes). (see Lesson_2..ipynb)</p>
      <p>The values are stored in order and you can access them by position</p>
      <p>You can also use <span class="inline_code">.loc[index_name]</span> to look up values by their indexes: <span class="inline_code">series_name.loc[index_name]</span> so you don't need to know the position in the list where the data exists</p>
      <p>For Series square brackets <span class="inline_code">[]</span> access elements <em>by position</em> (by default if indexes are not assigned)</p>
      <p>Pandas has <span class="inline_code">series_name.iloc[0]</span> which is functionally the same as <span class="inline_code">series_name[0]</span>, except that the first is more clean</p>

    <p><b>Quiz: Vectorized Operations and Series Indexes</b></p>
      <p>When you add two Numpy arrays, you're adding by position. How does this work for Series?</p>
      <p>Indexes are matched then added (or subtracted or whatever). Only matching indexes are added, etc. For values that don't overlap you get <span class="inline_code">NaN</span> = not a number</p>

    <p><b>Filling Missing Values</b></p>
      <p>What if we don't want <span class="inline_code">NaN</span>?</p>
      <p><span class="inline_code">series_name.dropna()</span> will exclude the NANs from the resulting series (see jupyter notebook)</p>
      <p>What if you want to treat missing values as 0 instead?</p>
      <p><span class="inline_code">series_name.fallna(value = 0)</span> will replace all NANs with the specified value (in this case 0), but this isn't quite what we want...</p>
      <p><p><span class="inline_code">series1.add(series2, fill_value=0)</span> will do the trick!</p>

    <p><b>Quiz: Pandas Series Apply()</b></p>
      <p>If you want to use non built-in calculations (other than .mean() or +)...</p>
      <ol>
        <li>Treat the series as a list (for loops, etc)</li>
        <li>Use the function <span class="inline_code">.apply()</span>, it takes a series and a function and returns a new series: <span class="inline_code">series_name.apply(function_name)</span></li>
      </ol>
      <p>This means you can define your own function and apply it to a series. Apply takes care of the looping for you, just write the function for a single input (see Lesson 2 ipynb)</p>

    <p><b>Quiz: Plotting in Pandas</b></p>
      <p>If the data is a Numpy array or Pandas Series, just like if it is a list use:</p>
      <div class="Code">
        <p>import matplotlib.pyplot as plt
          <br>plt.hist(series_or_array_name)</p>
      </div>
      <p>To create a histogram of the data</p>
      <p>Pandas also has built-in plotting that uses matplotlib behind the scenes, so if the data is a Series you can juse use <span class="inline_code">series_name.hist()</span></p>
      <p>You can make a line plot of a series using <span class="inline_code">series_name.plot()</span> where the index will be used for the x-axis and the values for the y-axis</p>
      <p>Recall that you may need to add <span class="inline_code">plt.show()</span> to your code when running locally</p>
      <p>Also recall that, to show the plots within your jupyter notebook, you should include the line <span class="inline_code">%pylab inline</span></p>
    
  <h3 class="NotesTitle">Lesson 3: Numpy and Pandas for 2D Data</h3>

    <p><b>Quiz: Subway Data</b></p>
      <p>Questions from the video:</p>
        <ul>
          <li>What variables are related to subway ridership?</li>
          <li>What patterns are there in the weather?</li>
        </ul>

    <p><b>Quiz: 2D Numpy Arrays</b></p>
      <p>2D: data with both rows and columns!</p>
      <p>In Python you could use a list of lists where each list represents a row</p>
      <p>In Numpy, instead of creating an array of arrays, you can create a single 2D array</p>
      <p>In Pandas, you use a DataFrame for 2D data. Just like for 1D data, Pandas DataFrames have additional functionality!</p>
      <p>Why make 2D arrays instead of an array of arrays?</p>
        <ul>
          <li>More memory efficient</li>
          <li>Syntax for accessing elements is a bit different:
            <br>to accesss the data in row 1, column 3 of a 2D array [counting from 0!] use: array_name[1, 3] vs array of arrays: array_name[1][3]
            <br>You can also use a slice [1:3, 4:7] to access parts of the 2D array
            <br>The general syntax is <em>[row, column]</em></li>
          <li><span class="inline_code">.mean()</span> and other functions work on an entire array, calculating the mean (or whatever) of all of the values, regardless of what column or row they were in</li>
        </ul>
    
    <p><b>Quiz: Numpy Axis</b></p>
      <p>What if you want to calculate <span class="inline_code">.mean()</span>, etc. by row or column instead of using the entire 2D array?</p>
      <p>Most functions built into Numpy take an axis argument for this reason, e.x. <span class="inline_code">array_name.mean(axis=0)</span>. Axis can be either 0 or 1. Axis = 0 calculates the function for each column. Axis = 1 calculates the function for each row. The output is an array where each value corresponds to each col/row mean (or whatever)</p>

    <p><b>Numpy and Pandas Data Types</b></p>
      <p>Recall that each element in an array is expected to have the same type 
      (<span class="inline_code">.dtype</span>). If they are not the same, each element will be converted to a string! This is a benefit of DataFrames, each column is assumed to be a different type! DataFrames also have indexes similar to Pandas Series, there is an index value for each row and a name for each column. Create a DataFrame from a dictionary:</p>
      <div class="Code">
        <p>import pandas as pd</p>
        <p>new_dataframe = pd.DataFrame({
          <br>&nbsp;&nbsp;'key1': [value1, value2, value3],
          <br>&nbsp;&nbsp;'key2': [value1, value2, value3]
          <br>})</p>
      </div>
      <p>This will map column names to lists of values for that column. When you <span class="inline_code">print</span> the DataFrame it is displayed in a nice table. (COOL)</p>
      <p>Now you can take the <span class="inline_code">.mean()</span> of the DataFrame and it will take the mean of the numerical columns and ignore the others</p>
      <p>Recall that you can add booleans therefore you can also apparently take their mean?</p>
      <p>You can also use the axis argument to take the mean of each row instead, although it will only work if your rows all contain numerical data</p>

    <p><b>Quiz: Accessing Elements of a DataFrame</b></p>
      <p>You can use index argument for DataFrames to add titles to your rows (if applicable). Otherwise they default to numbers (0, 1, 2, etc).</p>
      <p>As for Series, you use <span class="inline_code">.loc(index_name)</span> to access a row by its index or position. You can access individual cells using <span class="inline_code">.iloc[row, column]</span>.</p>
      <p>I think the difference is that .iloc() takes numerical values and .loc() takes indexes (col and row names)</p>
      <p>You can use <span class="inline_code">.values()</span> to get a 2D Numpy array containing <em>only the values</em> from your DataFrame. This would be useful if you wanted to take the mean of all of the values (if this was relevant to your data)</p>

    <p><b>Loading Data into a DataFrame</b></p>
      <p>DataFrames are particularly good for representing the contents of a CSV file!</p>
      <p><span class="inline_code">pd.read_csv('filename.csv')</span> takes in a CSV and loads it into a DataFrame:</p>
      <div class="Code">
        <p>import pandas as pd</p>
        <p>new_dataframe = pd.read_csv('filename.csv')</p>
      </div>
      <p><span class="inline_code">dataframe_name.head()</span> will print out the first 5 lines so you can take a look (see Jupyter notebook)</p>
      <p><span class="inline_code">dataframe_name.describe()</span> will show some statistics about each column</p>

    <p><b>Quiz: Calculating Correlation</b></p>
      <p><b>Pearson's r</b>
      <br>r = average of (x in std units) x (y in std units)</p>
      <br>First standardize each variable (convert to number of std dev above or below the mean), then multiply each pair of values and take the average.</p>
      <p>A positive result (r) indicates correlation (both increase or both decrease). Negative means that as one increases, the other decreases or vice versa.</p>
      <p>r ranges from -1 to +1, near 0 indicates that the variables are not strongly correlated.</p>
      <p>Pearson's r only measures linear correlation!</p>
      <p>When standardizing x and y, you need to include the argument ddof=0 in Pandas std dev function: <span class="inline_code">variable.std(ddof=0)</span> this argument controls whether the corrected or uncorrected std dev is taken (0 --> uncorrected).</p>

    <p><b>Pandas Axis Names</b></p>
      <p>Just like for 2D arrays, Pandas uses axis (e.x. axis = 0 or axis = 1). For Pandas you can also use axis = 'index' (columns) or axis = 'columns' (rows), e.x. taking <span class="inline_code">dataframe_name.mean(axis = 'columns')</span> will take the mean of each <em>ROW</em> not each column. "You are taking the mean ALONG the columns"" not OF the columns."</p>

    <p><b>Quiz: DataFrame Vectorized Operations</b></p>
      <p>Similar to those for 2D Numpy Arrays. Match up by index and column name rather than position.</p>
      <p>Just like with arrays, adding partially overlapping DataFrames returns NaN where there is no overlap</p>
      <p><span class="inline_code">.shift()</span> function appears to shift everything down one row. Documentation says you can specify how far to shift using the parameter <span class="inline_code">periods = 1</span> (one row).</p>

    <p><b>Quiz: DataFrame Applymap()</b></p>
      <p>Using non-built-in functions for DataFrames (like .apply() for Series above).</p>

    <p><b>Quiz: DataFrame Apply</b></p>
      <p>For DataFrames we use .applymap() because .apply does something different...</p>
      <p>.applymap() applies to the entire DataFrame, .apply only to each individual column</p>
      <p>For example, if you want to subtract the mean of the column from each value in that column you would use .apply() otherwise you might subtract the mean of the entire DataFrame, which wouldn't make sense (see jupyter notebook)</p>
      <p>.apply() also takes an axis argument if you want to go by rows instead</p>
      <p>Some built-in functions don't work on DataFrames so we can use .apply to call the function on each column seperately to get around this</p>

    <p><b>Quiz: DataFrame Apply() Use Case 2</b></p>
      <p>Instead of taking in a column and returning a column, your function could return a single value. In this case, calling it on a DataFrame will return a Series where each column corresponds to a single value</p>
      <p>e.x. <span class="inline_code">dataframe_name.apply(np.max)</span> to return the max value for each column</p>

    <p><b>Quiz: Adding a DataFrame to a Series</b></p>
      <p>...Using vectorized operations</p>
      <p>After looking at the result, I think it makes more sense to say "adding a series to DataFrame" (see Jupyter notebook)</p>
      <p>Recall that each value in a series is effectively a column. Or, a Series is a 2D table with <em>only one row</em>!</p>
      <p><span class="inline_code">.add()</span> function can take an argument that lets you treat the Series as a column with multiple rows if you want to get around the default</p>

    <p><b>Quiz: Standardizing Each Column Again</b></p>
      <p>...Without using .apply()</p>
      <p>Recall that when adding a Series (s) to a DataFrame (df), setting axis = 'index' will add each successive value in the Series to a different index (row) of the DataFrame (see Jupyter notebook). Kind of like treating the Series as a column (vs axis = 'column' which will treat the Series like a row)</p>

    <p><b>Quiz: Pandas Groupby()</b></p>
      <p>E.x. subway data: group data by hour of day, whether or not it was raining, or day of the week</p>
      <p>You are grouping by a 'key'' in your DataFrame 'dictionary'</p>
      <p>For example, to find the average amount of time students spent in the classroom in the Lesson 1 dataset:
      <div class="Code">
        <p>dataframe_name.groupby('key_to_group').sum()['key_to_sum'].mean()</p>
        <p>dataframe_name.groupby('key_to_group').sum()['key_to_sum'].describe()</p>
      </div>
      <p>The above code will group the data for each 'key_to_group' and then take the sum of the associated 'key_to_sum' data for each 'key_to_group'. Finally, it takes the mean of the summed data. Or, uses the describe() function to output additional stats.</p>
      <p>It is important to note that this creates a custom data type (groupby object) that you are summing (or whatever). If there is no built-in function to do what you want, you can use .apply() and write your own.</p>
      <p>After you've taken the sum, you've essentially created a new Series that can be printed or plotted (or whatever)</p>

    <p><b>Quiz: Calculating Hourly Entries and Exits</b></p>
      <p>You can groupby() some column and then filter out the unrelated columns before performing an analysis:</p>
      <div class="Code">
        <p>dataframe_name.groupby(['group_by_this_col'])['col_to_keep1', 'col_to_keep2'].apply(function_name)</p>
      </div>

    <p><b>Quiz: Combining Pandas DataFrames</b></p>
      <p>Pandas has an operation called merge that will combine two tables (DataFrames) into one</p>
      <p>Check for duplicates before performing merge!</p>
      <div class="Code">
        <p>first_dataframe.merge(second_dataframe, on = 'match_via', how='left')</p>
      </div>
      <p>Note that how has options, 'left' tells the merge to keep any rows from 'first_dataframe' (which is on the left as written) even if there are no related values in the right table ('second_dataframe'). 'right' does the opposite, 'outer' keeps all rows from both tables, 'inner' is probably the most common and only keeps rows where 'match_via' is represented in BOTH DataFrames</p>
      <p><em>What if you want to merge, but the columns have different names in the two DataFrames?</em></p>
      <p>For example, what if one was labeled 'DATEn' while the other was 'date'?</p>
      <p>You can specify left_on='DATEn' and right_on='date'. Once again, left and right correspond to how the .merge() was written.</p>

    <p><b>Quiz: Plotting for DataFrames</b></p>
      <p>Just like for Pandas Series, DataFrames have a .plot() method:dataframe_name.plot()</p>
      <p>This will work, but using matplotlib is definitely a better idea!</p>












<!-- Blank notes div:

<div class="CodeParent">
  <div class="CodeLeft">
    <p></p>
  </div>
  <div class="CodeRight">
    <ul>
      <li></li>
    </ul>
  </div>
</div>

-->


</div>
          


</div><!-- this closes "NotesMaster" -->
</body>
</html>


